{{ define "detail" }}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Job {{.Job.ID}}</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      body {
        margin: 0;
        font-family: monospace;
        background-color: #1e1e1e;
        color: #d4d4d4;
      }

      .detail-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      nav {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
      }

      header {
        background: #333;
        padding: 1em;
        border-radius: 4px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .breadcrumbs {
        display: flex;
        align-items: center;
        gap: 0.5em;
        margin-bottom: 1em;
        min-height: 18px;
      }

      .breadcrumb-path {
        text-decoration: none;
        color: #61dafb;
        opacity: 0.8;
        transition: opacity 0.2s ease;
      }

      .breadcrumb-path:hover {
        opacity: 1;
      }

      .breadcrumb-seperator {
        color: #666;
        display: inline-block;
      }

      .breadcrumb-leaf {
        color: #cfcfcf;
        font-weight: bold;
      }

      .meta-info {
        margin-top: 0.5em;
        font-size: 0.9em;
        color: #d4d4d4;
      }

      .meta-info div {
        margin-bottom: 0.5em;
      }

      .meta-info strong {
        color: #ffffff;
      }

      .terminal {
        background: #1e1e1e;
        border: 1px solid #333;
        border-radius: 4px;
        height: 60vh;
        overflow-y: auto;
        margin-bottom: 20px;
      }

      .terminal-content {
        padding: 1em;
      }

      .terminal-line {
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 1.4em;
        color: #d4d4d4;
        font-family: monospace;
      }

      button {
        background: none;
        border: 1px solid #61dafb;
        color: #61dafb;
        font-family: inherit;
        font-size: 0.9em;
        padding: 0.3em 0.8em;
        cursor: pointer;
        border-radius: 3px;
        transition: all 0.2s ease;
        margin-left: 1em;
      }

      button:hover {
        background: #61dafb;
        color: #1e1e1e;
      }

      button:active {
        background: #4fa8c5;
        border-color: #4fa8c5;
      }

      /* Scrollbar styling */
      .terminal::-webkit-scrollbar {
        width: 8px;
      }
      .terminal::-webkit-scrollbar-track {
        background: #2a2a2a;
      }
      .terminal::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }
      .terminal::-webkit-scrollbar-thumb:hover {
        background: #777;
      }

      /* Status styling */
      .status-section {
        display: flex;
        align-items: center;
        gap: 0.5em;
        margin-bottom: 0.8em;
      }

      /* Base styles for the job status circle */
      .job-status {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-left: 0.5em;
      }

      /* Status colors - matching the list view */
      .job-status.pending {
        background-color: #f1c40f;
        border: none;
        animation: none;
      }

      .job-status.in-progress {
        background-color: transparent;
        border: 2px solid #3498db;
        border-top-color: transparent;
        border-radius: 50%;
        animation: rotate 1.5s linear infinite;
      }

      .job-status.completed {
        background-color: #2ecc71;
        border: none;
        animation: none;
      }

      .job-status.cancelled {
        background-color: #f39c12;
        border: none;
        animation: none;
      }

      .job-status.error {
        background-color: #e74c3c;
        border: none;
        animation: none;
      }

      .status-text {
        font-weight: bold;
        padding: 0.2em 0.5em;
        border-radius: 3px;
        font-size: 0.9em;
      }

      .status-text.pending {
        color: #f1c40f;
        background-color: rgba(241, 196, 15, 0.1);
      }

      .status-text.in-progress {
        color: #3498db;
        background-color: rgba(52, 152, 219, 0.1);
      }

      .status-text.completed {
        color: #2ecc71;
        background-color: rgba(46, 204, 113, 0.1);
      }

      .status-text.cancelled {
        color: #f39c12;
        background-color: rgba(243, 156, 18, 0.1);
      }

      .status-text.error {
        color: #e74c3c;
        background-color: rgba(231, 76, 60, 0.1);
      }

      /* Command styling */
      .command-section {
        margin-bottom: 0.8em;
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        gap: 0.3em;
      }

      .command-name {
        color: #61dafb;
        font-family: monospace;
        font-weight: bold;
      }

      .command-args {
        color: #98c379;
        font-family: monospace;
      }

      .command-input {
        color: #e5c07b;
        font-family: monospace;
        font-weight: bold;
        background-color: rgba(229, 192, 123, 0.1);
        padding: 0.2em 0.4em;
        border-radius: 3px;
        border: 1px solid rgba(229, 192, 123, 0.3);
      }

      /* Rotate animation for In Progress */
      @keyframes rotate {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      @media screen and (max-width: 800px) {
        .detail-container {
          padding: 12px;
        }
        h1 {
          font-size: 1.4em;
        }
        header {
          padding: 0.8em;
        }
        .command-section {
          gap: 0.4em;
        }
        .terminal {
          height: 50vh;
        }
        button {
          margin-left: 0.5em;
        }
      }
    </style>
  </head>
  <body>
    <div class="detail-container">
      <h1>Shrike Job Manager</h1>
      {{ template "topnav" . }} {{template "detailHeader" .Job}}

      <div class="terminal">
        <div class="terminal-content">
          {{range $index, $line := .Job.Stdout }}
          <div class="terminal-line">{{$line}}</div>
          {{end}}
        </div>
      </div>
    </div>

    <script>
      // EVENT SOURCE CONNECTION (robust, lifecycle-aware)
      document.addEventListener("DOMContentLoaded", function () {
        const STREAM_URL = "/stream";
        const EVENT_STDOUT = "stdout-{{.Job.ID}}";
        const EVENT_UPDATE = "update";

        const sseState = {
          es: null,
          reconnectTimer: null,
          heartbeatTimer: null,
          connectingTimer: null,
          backoffMs: 1000,
          maxBackoffMs: 30000,
          isConnecting: false,
          isExplicitlyClosed: false,
          lastActivityTs: Date.now(),
          lifecycleSetup: false,
        };

        function withJitter(ms) {
          const jitter = Math.floor(ms * 0.2 * Math.random());
          return ms + jitter;
        }

        function resetBackoff() {
          sseState.backoffMs = 1000;
        }

        function onActivity() {
          sseState.lastActivityTs = Date.now();
          resetBackoff();
        }

        function stopHeartbeat() {
          if (sseState.heartbeatTimer) {
            clearInterval(sseState.heartbeatTimer);
            sseState.heartbeatTimer = null;
          }
        }

        function startHeartbeat() {
          stopHeartbeat();
          sseState.heartbeatTimer = setInterval(() => {
            const inactiveMs = Date.now() - sseState.lastActivityTs;
            // If we have been idle for too long, recreate the connection in case it's stale
            if (inactiveMs > 45000) {
              console.warn("SSE idle too long; recreating connection");
              recreateConnection();
            }
          }, 15000);
        }

        function clearConnectingTimer() {
          if (sseState.connectingTimer) {
            clearTimeout(sseState.connectingTimer);
            sseState.connectingTimer = null;
          }
        }

        function scheduleReconnect(reason) {
          if (sseState.isExplicitlyClosed) return;
          if (sseState.reconnectTimer) return;
          const delay = withJitter(sseState.backoffMs);
          console.log(`SSE reconnect in ${delay}ms (${reason || ""})`);
          sseState.reconnectTimer = setTimeout(() => {
            sseState.reconnectTimer = null;
            connect();
          }, delay);
          sseState.backoffMs = Math.min(
            sseState.maxBackoffMs,
            sseState.backoffMs * 2
          );
        }

        function cleanupES(markExplicit) {
          if (markExplicit) sseState.isExplicitlyClosed = true;
          stopHeartbeat();
          clearConnectingTimer();
          if (sseState.es) {
            try {
              sseState.es.close();
            } catch (e) {}
          }
          sseState.es = null;
          sseState.isConnecting = false;
        }

        function recreateConnection() {
          cleanupES(false);
          connect();
        }

        function connect() {
          if (sseState.isConnecting) return;
          if (sseState.es && sseState.es.readyState !== EventSource.CLOSED)
            return;
          if (!navigator.onLine) {
            scheduleReconnect("offline");
            return;
          }
          if (document.visibilityState === "hidden") {
            scheduleReconnect("hidden");
            return;
          }

          sseState.isConnecting = true;
          try {
            console.log("SSE connecting...");
            const es = new EventSource(STREAM_URL);
            sseState.es = es;

            // Safety: if we are stuck in CONNECTING for too long, recreate
            clearConnectingTimer();
            sseState.connectingTimer = setTimeout(() => {
              if (
                sseState.es &&
                sseState.es.readyState === EventSource.CONNECTING
              ) {
                console.warn("SSE stuck CONNECTING; recreating");
                recreateConnection();
              }
            }, 20000);

            es.onopen = () => {
              sseState.isConnecting = false;
              clearConnectingTimer();
              onActivity();
              startHeartbeat();
              console.log("SSE connected");
            };

            es.onerror = (error) => {
              console.warn("SSE error", error);
              onActivity();
              if (!sseState.es) return; // already cleaned
              if (sseState.es.readyState === EventSource.CLOSED) {
                cleanupES(false);
                scheduleReconnect("closed");
              } else if (sseState.es.readyState === EventSource.CONNECTING) {
                // Browser will retry; still schedule a guarded reconnect
                scheduleReconnect("connecting");
              }
            };

            // Append stdout lines
            es.addEventListener(EVENT_STDOUT, function (e) {
              onActivity();
              var data = JSON.parse(e.data);
              if (data.line) {
                var container = document.querySelector(".terminal-content");
                if (!container) return;
                var newLine = document.createElement("div");
                newLine.className = "terminal-line";
                newLine.textContent = data.line;
                container.appendChild(newLine);
                if (container.parentElement) {
                  container.parentElement.scrollTop =
                    container.parentElement.scrollHeight;
                }
              }
            });

            // Update job status
            es.addEventListener(EVENT_UPDATE, function (e) {
              onActivity();
              var data = JSON.parse(e.data);
              if (data.job && String(data.job.id) === "{{.Job.ID}}") {
                const stateString = jobStateToString(data.job.state);
                const stateClass = jobStateToClass(data.job.state);

                var stateEl = document.getElementById("state");
                if (stateEl) stateEl.innerText = stateString;

                const statusIcon = document.querySelector(".job-status");
                const statusText = document.getElementById("state");

                const stateClasses = [
                  "pending",
                  "in-progress",
                  "completed",
                  "cancelled",
                  "error",
                ];
                if (statusIcon && statusText) {
                  stateClasses.forEach((cls) => {
                    statusIcon.classList.remove(cls);
                    statusText.classList.remove(cls);
                  });
                  statusIcon.classList.add(stateClass);
                  statusText.classList.add(stateClass);
                }

                if (
                  stateString === "Completed" ||
                  stateString === "Cancelled" ||
                  stateString === "Error"
                ) {
                  var cancelBtn = document.getElementById("cancel");
                  if (cancelBtn) cancelBtn.style.display = "none";
                }

                if (data.job.completed_at) {
                  var completedAt = document.getElementById("completedAt");
                  if (completedAt)
                    completedAt.innerText = data.job.completed_at;
                }
                if (data.job.errored_at) {
                  var erroredAt = document.getElementById("erroredAt");
                  if (erroredAt) erroredAt.innerText = data.job.errored_at;
                }
              }
            });
          } catch (e) {
            console.error("SSE connect threw", e);
            sseState.isConnecting = false;
            scheduleReconnect("exception");
          }
        }

        function setupLifecycle() {
          if (sseState.lifecycleSetup) return;
          sseState.lifecycleSetup = true;

          // Online/offline
          window.addEventListener("online", () => {
            resetBackoff();
            connect();
          });
          window.addEventListener("offline", () => {
            cleanupES(false);
          });

          // Page visibility
          document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "visible") {
              resetBackoff();
              connect();
            }
          });

          // Window focus: ensure we are connected or refresh stale connection
          window.addEventListener("focus", () => {
            resetBackoff();
            if (!sseState.es || sseState.es.readyState === EventSource.CLOSED) {
              connect();
            } else {
              const inactiveMs = Date.now() - sseState.lastActivityTs;
              if (inactiveMs > 15000) {
                // If connection looks stale after being in background, recreate it
                recreateConnection();
              }
            }
          });

          // bfcache lifecycle
          window.addEventListener("pageshow", (e) => {
            // When restored from bfcache, re-establish the connection
            resetBackoff();
            connect();
          });

          window.addEventListener("pagehide", () => {
            // Close without marking explicit so we can reconnect on pageshow
            cleanupES(false);
          });

          // Hard unload fallback
          window.addEventListener("beforeunload", () => {
            cleanupES(true);
          });
        }

        setupLifecycle();
        // Initial connect (soon as DOM is ready)
        connect();
      });

      function cancelJob(e) {
        e.preventDefault();
        const id = e.target.getAttribute("data-id");
        fetch(`/job/${id}/cancel`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        })
          .then((response) => response.text())
          .then((result) => {
            console.log("Server responded:", result);
          })
          .catch((err) => console.error("Error:", err));
      }

      function htmlToNode(html) {
        const template = document.createElement("template");
        template.innerHTML = html.trim();
        const nNodes = template.content.childNodes.length;
        if (nNodes !== 1) {
          throw new Error(
            `html parameter must represent a single node; got ${nNodes}. ` +
              "Note that leading or trailing spaces around an element in your " +
              'HTML, like " <img/> ", get parsed as text nodes neighbouring ' +
              "the element; call .trim() on your input to avoid this."
          );
        }
        return template.content.firstChild;
      }

      function jobStateToString(state) {
        switch (state) {
          case 0:
            return "Pending";
          case 1:
            return "InProgress";
          case 2:
            return "Completed";
          case 3:
            return "Cancelled";
          case 4:
            return "Error";
          default:
            return "Unknown";
        }
      }

      function jobStateToClass(state) {
        switch (state) {
          case 0:
            return "pending";
          case 1:
            return "in-progress";
          case 2:
            return "completed";
          case 3:
            return "cancelled";
          case 4:
            return "error";
          default:
            return "pending";
        }
      }
    </script>
  </body>
</html>
{{ end }}
