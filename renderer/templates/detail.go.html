{{ define "detail" }}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Job {{.Job.ID}}</title>
    <link rel="stylesheet" href="/static/details.css" />
  </head>
  <body>
    {{template "detailHeader" .Job}}
    <div class="terminal">
      <div class="terminal-content">
        {{range $index, $line := .Job.Stdout }}
        <div class="terminal-line">{{$line}}</div>
        {{end}}
      </div>
    </div>
    <footer></footer>

    <script>
      // EVENT SOURCE CONNECTION
      document.addEventListener("DOMContentLoaded", function () {
        let eventSource = null;
        const connectEventSource = () => {
          if (!navigator.onLine) {
            console.warn("Offline. EventSource will not connect.");
            return;
          }

          console.log("Connecting to EventSource...");
          eventSource = new EventSource("/stream");

          eventSource.onopen = () => {
            console.log("EventSource connected.");
          };

          eventSource.onerror = (error) => {
            console.error("EventSource error:", error);
            if (eventSource.readyState === EventSource.CLOSED) {
              console.log("Retrying EventSource connection in 3 seconds...");
              setTimeout(connectEventSource, 3000); // Retry connection after 3 seconds
            }
          };

          // Listen for stdout events and append the line to the terminal
          eventSource.addEventListener("stdout-{{.Job.ID}}", function (e) {
            var data = JSON.parse(e.data);
            if (data.line) {
              var container = document.querySelector(".terminal-content");
              var newLine = document.createElement("div");
              newLine.className = "terminal-line";
              newLine.textContent = data.line;
              container.appendChild(newLine);
              container.parentElement.scrollTop =
                container.parentElement.scrollHeight;
            }
          });

          eventSource.addEventListener("update", function (e) {
            var data = JSON.parse(e.data);
            console.log(data);
            if (data.job.id === "{{.Job.ID}}") {
              // Update the jobs state
              const stateString = jobStateToString(data.job.state);
              document.getElementById("state").innerText = stateString;

              if (
                stateString === "Completed" ||
                stateString === "Cancelled" ||
                stateString === "Error"
              ) {
                document.getElementById("cancel").style.display = "none";
              }

              // Update either the completed or errored at time
              if (data.job.completed_at) {
                document.getElementById("completedAt").innerText =
                  data.job.completed_at;
              }

              if (data.job.errored_at) {
                document.getElementById("erroredAt").innerText =
                  data.job.errored_at;
              }
            }
          });
        };

        connectEventSource();

        window.addEventListener("beforeunload", (e) => {
          console.log(e);
          if (eventSource) {
            eventSource.close();
            console.log("EventSource connection closed.");
          }
        });

        window.addEventListener("online", connectEventSource);
        window.addEventListener("offline", () => {
          if (eventSource) {
            eventSource.close();
            console.log("EventSource closed due to offline status.");
          }
        });
      });

      function cancelJob(e) {
        e.preventDefault();
        const id = e.target.getAttribute("data-id");
        fetch(`/job/${id}/cancel`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        })
          .then((response) => response.text())
          .then((result) => {
            console.log("Server responded:", result);
          })
          .catch((err) => console.error("Error:", err));
      }

      function htmlToNode(html) {
        const template = document.createElement("template");
        template.innerHTML = html.trim();
        const nNodes = template.content.childNodes.length;
        if (nNodes !== 1) {
          throw new Error(
            `html parameter must represent a single node; got ${nNodes}. ` +
              "Note that leading or trailing spaces around an element in your " +
              'HTML, like " <img/> ", get parsed as text nodes neighbouring ' +
              "the element; call .trim() on your input to avoid this."
          );
        }
        return template.content.firstChild;
      }

      function jobStateToString(state) {
        switch (state) {
          case 0:
            return "Pending";
          case 1:
            return "InProgress";
          case 2:
            return "Completed";
          case 3:
            return "Cancelled";
          case 4:
            return "Error";
          default:
            return "Unknown";
        }
      }
    </script>
  </body>
</html>
{{ end }}
