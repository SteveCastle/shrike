{{ define "media" }}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Shrike Media Browser</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      .media-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      .media-table {
        width: 100%;
        border-collapse: collapse;
        font-family: monospace;
        background-color: #1e1e1e;
        color: #d4d4d4;
        margin: 0;
      }

      .media-header,
      .media-row {
        display: grid;
        grid-template-columns: 40px 3fr 2fr 80px 80px 100px 80px 1.5fr 140px 2fr;
        gap: 8px;
        border-bottom: 1px solid #333;
        align-items: start;
        min-height: 40px;
      }

      .media-header {
        font-weight: bold;
        background-color: #333;
        color: #ffffff;
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .media-cell {
        position: relative;
        padding: 10px;
        text-align: left;
        box-sizing: border-box;
        color: #d4d4d4;
        white-space: nowrap;
        display: flex;
        align-items: center;
        overflow: hidden;
      }

      .media-cell.checkbox {
        justify-content: center;
        padding: 8px;
      }

      .media-cell.checkbox input[type="checkbox"] {
        transform: scale(1.2);
        cursor: pointer;
      }

      .media-cell.path {
        font-family: monospace;
        color: #61dafb;
        word-break: break-all;
        white-space: normal;
        cursor: pointer;
        transition: color 0.2s ease;
      }

      .media-cell.path:hover {
        color: #4fa8d8;
      }

      .media-cell.description {
        color: #d4d4d4;
        white-space: normal;
        word-break: break-word;
        max-height: 80px;
        overflow-y: auto;
        overflow-x: hidden;
        scrollbar-width: thin;
        scrollbar-color: #555 #2d2d2d;
        display: block;
        padding: 8px 10px;
        line-height: 1.4;
        box-sizing: border-box;
        text-align: left;
      }

      .media-cell.description::-webkit-scrollbar {
        width: 6px;
      }

      .media-cell.description::-webkit-scrollbar-track {
        background: #2d2d2d;
        border-radius: 3px;
      }

      .media-cell.description::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 3px;
      }

      .media-cell.description::-webkit-scrollbar-thumb:hover {
        background: #666;
      }

      .media-cell.dimensions {
        color: #e5c07b;
        text-align: center;
        justify-content: center;
        font-size: 0.9em;
      }

      .media-cell.size {
        color: #98c379;
        text-align: right;
        justify-content: flex-end;
      }

      .media-cell.exists {
        text-align: center;
        justify-content: center;
        font-size: 1.2em;
      }

      .media-cell.hash {
        font-family: monospace;
        color: #e06c75;
        font-size: 0.9em;
        word-break: break-all;
      }

      .media-cell.tags {
        color: #c678dd;
        font-size: 0.85em;
        line-height: 1.2;
        white-space: normal;
        word-break: break-word;
        align-items: flex-start;
        overflow: visible;
        padding-top: 8px;
        padding-bottom: 8px;
        max-width: 200px;
        min-width: 150px;
        display: flex;
        flex-wrap: wrap;
      }

      .tag-item {
        display: inline-block;
        background-color: #444;
        color: #fff;
        padding: 1px 4px;
        margin: 1px 1px;
        border-radius: 3px;
        font-size: 0.75em;
        white-space: nowrap;
        vertical-align: top;
        line-height: 1.3;
      }

      .tag-category {
        background-color: #666;
        color: #ccc;
        font-weight: bold;
      }

      .loading {
        text-align: center;
        padding: 20px;
        color: #888;
        font-style: italic;
      }

      .end-of-list {
        text-align: center;
        padding: 20px;
        color: #666;
        font-style: italic;
      }

      /* View toggle */
      .view-toggle {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-top: 10px;
      }
      .toggle-btn {
        padding: 6px 12px;
        background-color: #333;
        border: 1px solid #555;
        color: #d4d4d4;
        border-radius: 4px;
        cursor: pointer;
        font-family: monospace;
        font-size: 0.9em;
      }
      .toggle-btn.active {
        background-color: #61dafb;
        color: #000;
        border-color: #61dafb;
      }

      /* Grid view */
      .media-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 10px;
      }
      .grid-item {
        position: relative;
        width: 100%;
        aspect-ratio: 1 / 1;
        background: #111;
        border: 1px solid #333;
        border-radius: 6px;
        overflow: hidden;
        cursor: pointer;
      }
      .grid-thumb {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .grid-badge {
        position: absolute;
        right: 6px;
        top: 6px;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 10px;
        pointer-events: none;
      }

      /* Lightbox overlay */
      .lightbox {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }
      .lightbox.show {
        display: flex;
      }
      .lightbox-content {
        max-width: 90vw;
        max-height: 90vh;
      }
      .lightbox-content img,
      .lightbox-content video {
        max-width: 100%;
        max-height: 90vh;
        object-fit: contain;
        border-radius: 8px;
      }
      .lightbox-close {
        position: absolute;
        top: 16px;
        right: 16px;
        background: #333;
        color: #fff;
        border: 1px solid #555;
        padding: 6px 10px;
        border-radius: 4px;
        cursor: pointer;
      }

      /* Bulk Actions Panel */
      .bulk-actions {
        position: sticky;
        top: 80px;
        z-index: 5;
        background: linear-gradient(135deg, #2d2d2d, #1e1e1e);
        border: 2px solid #61dafb;
        border-radius: 8px;
        padding: 15px;
        margin: 20px 0;
        display: none;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .bulk-actions.show {
        display: block;
      }

      .bulk-actions-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .bulk-actions-title {
        color: #61dafb;
        font-weight: bold;
        font-size: 1.1em;
      }

      .bulk-actions-count {
        background-color: #61dafb;
        color: #000;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.9em;
        font-weight: bold;
      }

      .bulk-actions-form {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .bulk-actions-form select {
        padding: 8px 12px;
        background-color: #1e1e1e;
        border: 1px solid #555;
        color: #d4d4d4;
        border-radius: 4px;
        font-family: monospace;
        min-width: 150px;
      }

      .bulk-actions-form button {
        padding: 8px 16px;
        background-color: #61dafb;
        color: #000;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s ease;
      }

      .bulk-actions-form button:hover {
        background-color: #4fa8d8;
      }

      .bulk-actions-form button:disabled {
        background-color: #666;
        color: #999;
        cursor: not-allowed;
      }

      .bulk-clear-btn {
        background-color: #666 !important;
        color: #fff !important;
      }

      .bulk-clear-btn:hover {
        background-color: #777 !important;
      }

      /* Media Preview Tooltip */
      .media-preview {
        position: fixed;
        display: none;
        z-index: 1000;
        background: linear-gradient(135deg, #2d2d2d, #1e1e1e);
        border: 2px solid #61dafb;
        border-radius: 12px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.7),
          0 5px 15px rgba(97, 218, 251, 0.2);
        max-width: 400px;
        max-height: 300px;
        overflow: hidden;
        backdrop-filter: blur(10px);
        transition: opacity 0.3s ease, transform 0.3s ease;
        opacity: 0;
        transform: translateY(10px) scale(0.95);
        pointer-events: none;
      }

      .media-preview.show {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      .media-preview-header {
        background: linear-gradient(90deg, #61dafb, #4fa8d8);
        color: #000;
        padding: 8px 12px;
        font-size: 12px;
        font-weight: bold;
        text-align: center;
        margin: 0;
      }

      .media-preview-content {
        position: relative;
        width: 100%;
        height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .media-preview img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 0;
      }

      .media-preview video {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 0;
      }

      .media-preview-loading {
        color: #61dafb;
        font-size: 14px;
        text-align: center;
        padding: 20px;
      }

      .media-preview-error {
        color: #e06c75;
        font-size: 12px;
        text-align: center;
        padding: 20px;
        line-height: 1.4;
      }

      .media-preview-footer {
        background: rgba(30, 30, 30, 0.95);
        color: #aaa;
        padding: 6px 12px;
        font-size: 10px;
        text-align: center;
        border-top: 1px solid #333;
      }

      /* Responsive adjustments */
      @media screen and (max-width: 800px) {
        .media-header,
        .media-row {
          grid-template-columns: 1fr;
          gap: 0;
        }

        .media-cell {
          padding: 5px 10px;
          border-bottom: 1px dotted #444;
        }

        .media-cell:before {
          content: attr(data-label) ": ";
          font-weight: bold;
          color: #aaa;
          margin-right: 10px;
        }

        .media-header {
          display: none;
        }

        .media-cell.tags {
          max-width: none;
          min-width: auto;
        }

        .tag-item {
          margin: 1px 1px;
          font-size: 0.75em;
          padding: 1px 3px;
        }

        .media-preview {
          max-width: 90vw;
          max-height: 60vh;
        }

        .media-preview-content {
          height: 150px;
        }

        .bulk-actions-form {
          flex-direction: column;
          align-items: stretch;
        }

        .bulk-actions-form select,
        .bulk-actions-form button {
          width: 100%;
        }

        /* Metadata options responsive */
        #metadata-options div[style*="display: flex"] {
          flex-direction: column !important;
          align-items: stretch !important;
        }

        #metadata-options div[style*="display: flex"] label {
          min-width: auto !important;
        }

        #metadata-options select,
        #metadata-options input[type="text"] {
          width: 100% !important;
          min-width: auto !important;
        }

        #metadata-options div[style*="gap: 15px"] {
          gap: 10px !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="media-container">
      <h1>Media Browser</h1>
      <nav
        style="
          margin: 10px 0;
          padding: 10px;
          background-color: #333;
          border-radius: 4px;
        "
      >
        <a href="/" style="margin-right: 20px; color: #61dafb">Jobs</a>
        <a href="/media" style="margin-right: 20px; color: #61dafb"
          >Media Browser</a
        >
        <a href="/config" style="color: #61dafb">Config</a>
      </nav>

      <div class="view-toggle" style="margin-bottom: 10px">
        <span style="color: #aaa; font-size: 0.9em">View:</span>
        <button id="view-table" type="button" class="toggle-btn">Table</button>
        <button id="view-grid" type="button" class="toggle-btn">Grid</button>
      </div>

      <div
        style="
          margin: 20px 0;
          padding: 15px;
          background-color: #2d2d2d;
          border-radius: 4px;
        "
      >
        <form
          id="search-form"
          style="display: flex; gap: 10px; align-items: center"
        >
          <input
            type="text"
            id="search-input"
            placeholder='Search query (e.g., tag:"landscape" AND size:>1000000)'
            value="{{.SearchQuery}}"
            style="
              flex: 1;
              padding: 8px 12px;
              background-color: #1e1e1e;
              border: 1px solid #555;
              color: #d4d4d4;
              border-radius: 4px;
              font-family: monospace;
            "
          />
          <button
            type="submit"
            style="
              padding: 8px 16px;
              background-color: #61dafb;
              color: #000;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-weight: bold;
            "
          >
            Search
          </button>
          <button
            type="button"
            id="clear-search"
            style="
              padding: 8px 16px;
              background-color: #666;
              color: #fff;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            "
          >
            Clear
          </button>
        </form>

        <div style="margin-top: 10px; font-size: 0.9em; color: #aaa">
          <strong>Search Examples:</strong><br />
          • <code>path:"*.mp4"</code> - Files with .mp4 extension<br />
          • <code>size:>1000000</code> - Files larger than 1MB<br />
          • <code>description:"cat" AND size:<5000000</code> - Cat descriptions
          under 5MB<br />
          • <code>tag:"landscape"</code> - Media tagged as landscape<br />
          • <code>category:"nature" AND tag:"sunset"</code> - Nature category
          with sunset tag<br />
          • <code>NOT tag:"portrait"</code> - Media without portrait tag<br />
          • <code>tag:"*flower*" OR category:"garden"</code> - Flower tags or
          garden category<br />
          • <code>NOT hash:""</code> - Files with hash values<br />
          • <code>path:"*video*" OR path:"*movie*"</code> - Paths containing
          "video" or "movie"
        </div>
      </div>

      <!-- Bulk Actions Panel -->
      <div id="bulk-actions" class="bulk-actions">
        <div class="bulk-actions-header">
          <div class="bulk-actions-title">Bulk Actions</div>
          <div class="bulk-actions-count" id="selected-count">0 selected</div>
        </div>
        <form class="bulk-actions-form" id="bulk-actions-form">
          <select id="task-select" required>
            <option value="">Select task...</option>
            <option value="remove">Remove from Database</option>
            <option value="move">Move Files</option>
            <option value="metadata">Generate Metadata</option>
            <option value="autotag">Auto Tag (ONNX)</option>
          </select>
          <div
            id="metadata-options"
            style="
              display: none;
              flex-direction: column;
              gap: 10px;
              margin-top: 10px;
            "
          >
            <div style="color: #aaa; font-size: 0.9em; font-weight: bold">
              Metadata Types:
            </div>
            <div
              style="
                display: flex;
                gap: 15px;
                flex-wrap: wrap;
                margin-left: 10px;
              "
            >
              <label style="color: #aaa; font-size: 0.9em">
                <input
                  type="checkbox"
                  id="metadata-description"
                  style="margin-right: 5px"
                  checked
                />
                Description
              </label>
              <label style="color: #aaa; font-size: 0.9em">
                <input
                  type="checkbox"
                  id="metadata-transcript"
                  style="margin-right: 5px"
                />
                Transcript
              </label>
              <label style="color: #aaa; font-size: 0.9em">
                <input
                  type="checkbox"
                  id="metadata-hash"
                  style="margin-right: 5px"
                  checked
                />
                Hash
              </label>
              <label style="color: #aaa; font-size: 0.9em">
                <input
                  type="checkbox"
                  id="metadata-dimensions"
                  style="margin-right: 5px"
                  checked
                />
                Dimensions
              </label>
              <label style="color: #aaa; font-size: 0.9em">
                <input
                  type="checkbox"
                  id="metadata-autotag"
                  style="margin-right: 5px"
                />
                Auto Tag
              </label>
            </div>
            <div
              style="
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
              "
            >
              <label style="color: #aaa; font-size: 0.9em; min-width: 120px"
                >Apply Scope:</label
              >
              <select
                id="apply-scope-select"
                style="
                  padding: 6px 10px;
                  background-color: #1e1e1e;
                  border: 1px solid #555;
                  color: #d4d4d4;
                  border-radius: 4px;
                  font-family: monospace;
                  min-width: 120px;
                "
              >
                <option value="all">All selected files</option>
                <option value="new">New files only</option>
              </select>
            </div>
            <div
              style="
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
              "
            >
              <label style="color: #aaa; font-size: 0.9em; min-width: 120px"
                >AI Model:</label
              >
              <input
                type="text"
                id="ollama-model"
                value="llama3.2-vision"
                placeholder="e.g., llama3.2-vision"
                style="
                  padding: 6px 10px;
                  background-color: #1e1e1e;
                  border: 1px solid #555;
                  color: #d4d4d4;
                  border-radius: 4px;
                  font-family: monospace;
                  flex: 1;
                  min-width: 200px;
                "
              />
            </div>
            <div
              style="
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
              "
            >
              <label style="color: #aaa; font-size: 0.9em">
                <input
                  type="checkbox"
                  id="overwrite-checkbox"
                  style="margin-right: 5px"
                />
                Overwrite existing metadata
              </label>
            </div>
            <div style="font-size: 0.8em; color: #888; line-height: 1.3">
              <strong>Note:</strong> Description generation requires Ollama with
              a vision model. Transcript generation requires faster-whisper-xxl
              for video files. Hash and dimensions work for all media types.
            </div>
          </div>
          <div
            id="move-options"
            style="
              display: none;
              flex-direction: column;
              gap: 10px;
              margin-top: 10px;
            "
          >
            <div
              style="
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
              "
            >
              <label style="color: #aaa; font-size: 0.9em; min-width: 120px"
                >Target Directory:</label
              >
              <input
                type="text"
                id="target-directory-path"
                placeholder="e.g., /new/base/directory/"
                style="
                  padding: 6px 10px;
                  background-color: #1e1e1e;
                  border: 1px solid #555;
                  color: #d4d4d4;
                  border-radius: 4px;
                  font-family: monospace;
                  flex: 1;
                  min-width: 200px;
                "
              />
            </div>
            <div
              style="
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
              "
            >
              <label style="color: #aaa; font-size: 0.9em; min-width: 120px"
                >Path Prefix to Remove:</label
              >
              <input
                type="text"
                id="path-prefix"
                placeholder="e.g., /old/base/path/"
                style="
                  padding: 6px 10px;
                  background-color: #1e1e1e;
                  border: 1px solid #555;
                  color: #d4d4d4;
                  border-radius: 4px;
                  font-family: monospace;
                  flex: 1;
                  min-width: 200px;
                "
              />
            </div>
            <div style="font-size: 0.8em; color: #888; line-height: 1.3">
              <strong>Note:</strong> Files will be moved from their current
              location to the target directory. The path prefix will be removed
              from each file's current path before appending to the target
              directory.
            </div>
          </div>
          <button type="submit" id="execute-button">Execute</button>
          <button
            type="button"
            class="bulk-clear-btn"
            onclick="clearSelection()"
          >
            Clear Selection
          </button>
        </form>
      </div>

      <div id="media-table" class="media-table">
        <div class="media-header">
          <div class="media-cell checkbox">
            <input
              type="checkbox"
              id="select-all"
              onchange="toggleSelectAll(this)"
            />
          </div>
          <div class="media-cell">Path</div>
          <div class="media-cell">Description</div>
          <div class="media-cell">Width</div>
          <div class="media-cell">Height</div>
          <div class="media-cell">Size</div>
          <div class="media-cell">Exists</div>
          <div class="media-cell">Hash</div>
          <div class="media-cell">Job</div>
          <div class="media-cell">Tags</div>
        </div>
        <div id="media-list" class="table-body">
          {{range .MediaItems}}
          <div class="media-row">
            <div class="media-cell checkbox" data-label="Select">
              <input
                type="checkbox"
                class="media-checkbox"
                value="{{htmlAttr .Path}}"
                onchange="updateSelection()"
              />
            </div>
            <div
              class="media-cell path"
              data-label="Path"
              data-media-path="{{htmlAttr .Path}}"
              onmouseenter="showMediaPreview(event, this.dataset.mediaPath)"
              onmouseleave="hideMediaPreview()"
            >
              {{.Path}}
            </div>
            <div class="media-cell description" data-label="Description">
              {{if .Description.Valid}}{{.Description.String}}{{else}}-{{end}}
            </div>
            <div class="media-cell dimensions" data-label="Width">
              {{if .Width.Valid}}{{.Width.Int64}}{{else}}-{{end}}
            </div>
            <div class="media-cell dimensions" data-label="Height">
              {{if .Height.Valid}}{{.Height.Int64}}{{else}}-{{end}}
            </div>
            <div class="media-cell size" data-label="Size">
              {{.FormattedSize}}
            </div>
            <div class="media-cell exists" data-label="Exists">
              {{if .Exists}}✅{{else}}❌{{end}}
            </div>
            <div class="media-cell hash" data-label="Hash">
              {{if .Hash.Valid}}{{.Hash.String}}{{else}}-{{end}}
            </div>
            <div
              class="media-cell job"
              data-label="Job"
              data-media-path-job="{{htmlAttr .Path}}"
            ></div>
            <div class="media-cell tags" data-label="Tags">
              {{if .Tags}} {{range .Tags}}
              <span class="tag-item">
                <span class="tag-category">{{.Category}}</span>:{{.Label}}
              </span>
              {{end}} {{else}} - {{end}}
            </div>
          </div>
          {{end}}
        </div>
        <div id="loading" class="loading" style="display: none">
          Loading more items...
        </div>
        <div id="end-of-list" class="end-of-list" style="display: none">
          No more items to load
        </div>
      </div>
      <div id="media-grid" class="media-grid" style="display: none"></div>
    </div>

    <!-- Media Preview Tooltip -->
    <div id="media-preview" class="media-preview">
      <div class="media-preview-header" id="preview-header">Media Preview</div>
      <div class="media-preview-content" id="preview-content">
        <div class="media-preview-loading" id="preview-loading">Loading...</div>
      </div>
      <div class="media-preview-footer" id="preview-footer">
        Hover to preview media
      </div>
    </div>

    <!-- Lightbox for fullscreen media -->
    <div id="lightbox" class="lightbox" aria-hidden="true">
      <button id="lightbox-close" class="lightbox-close" type="button">
        Close
      </button>
      <div id="lightbox-content" class="lightbox-content"></div>
    </div>

    <script>
      let currentOffset = Number("{{.Offset}}") || 0;
      let isLoading = false;
      let hasMoreItems =
        "{{.HasMore}}" === "true" ||
        "{{.HasMore}}" === "1" ||
        "{{.HasMore}}" === "True";
      let currentSearchQuery = "{{.SearchQuery}}";

      // View mode state
      let currentViewMode = localStorage.getItem("mediaViewMode") || "table";
      let gridInitialized = false;
      let gridObserver = null;

      // Selection management
      let selectedItems = new Set();

      function updateSelection() {
        selectedItems.clear();
        const checkboxes = document.querySelectorAll(".media-checkbox:checked");
        checkboxes.forEach((cb) => selectedItems.add(cb.value));

        const count = selectedItems.size;
        document.getElementById(
          "selected-count"
        ).textContent = `${count} selected`;

        const bulkActions = document.getElementById("bulk-actions");
        if (count > 0) {
          bulkActions.classList.add("show");
        } else {
          bulkActions.classList.remove("show");
        }

        // Update select-all checkbox state
        const allCheckboxes = document.querySelectorAll(".media-checkbox");
        const selectAllCheckbox = document.getElementById("select-all");
        if (count === 0) {
          selectAllCheckbox.indeterminate = false;
          selectAllCheckbox.checked = false;
        } else if (count === allCheckboxes.length) {
          selectAllCheckbox.indeterminate = false;
          selectAllCheckbox.checked = true;
        } else {
          selectAllCheckbox.indeterminate = true;
          selectAllCheckbox.checked = false;
        }
      }

      function toggleSelectAll(checkbox) {
        const mediaCheckboxes = document.querySelectorAll(".media-checkbox");
        mediaCheckboxes.forEach((cb) => {
          cb.checked = checkbox.checked;
        });
        updateSelection();
      }

      function clearSelection() {
        const checkboxes = document.querySelectorAll(
          ".media-checkbox, #select-all"
        );
        checkboxes.forEach((cb) => {
          cb.checked = false;
          cb.indeterminate = false;
        });
        updateSelection();
      }

      // Show/hide options based on task selection
      document
        .getElementById("task-select")
        .addEventListener("change", function () {
          const metadataOptions = document.getElementById("metadata-options");
          const moveOptions = document.getElementById("move-options");

          // Hide all options first
          metadataOptions.style.display = "none";
          moveOptions.style.display = "none";

          // Show relevant options
          if (this.value === "metadata") {
            metadataOptions.style.display = "flex";
          } else if (this.value === "move") {
            moveOptions.style.display = "flex";
          }
        });

      // Handle bulk actions form submission
      document
        .getElementById("bulk-actions-form")
        .addEventListener("submit", function (e) {
          e.preventDefault();

          const taskSelect = document.getElementById("task-select");
          const selectedTask = taskSelect.value;
          const overwriteCheckbox =
            document.getElementById("overwrite-checkbox");
          const executeButton = document.getElementById("execute-button");

          if (!selectedTask) {
            alert("Please select a task to execute");
            return;
          }

          if (selectedItems.size === 0) {
            alert("Please select at least one media item");
            return;
          }

          // Prepare the command based on selected task
          let command,
            args = [],
            input;

          if (selectedTask === "remove") {
            command = "remove";
            args = [];
            input = Array.from(selectedItems).join("\n");
          } else if (selectedTask === "move") {
            command = "move";
            args = [];

            // Get target directory from text input
            const targetDirectoryInput = document.getElementById(
              "target-directory-path"
            );
            const pathPrefixInput = document.getElementById("path-prefix");

            const targetPath = targetDirectoryInput.value.trim();

            // Validate target path
            if (!targetPath) {
              alert("Please enter a target directory path");
              return;
            }

            // Add target directory as first argument (no flag)
            args.push(targetPath);

            // Add path prefix if specified
            const pathPrefix = pathPrefixInput.value.trim();
            if (pathPrefix) {
              args.push("--prefix", pathPrefix);
            }

            // Create newline-separated list of files
            input = Array.from(selectedItems).join("\n");
          } else if (selectedTask === "metadata") {
            command = "metadata";
            args = [];

            // Get selected metadata types
            const metadataTypes = [];
            if (document.getElementById("metadata-description").checked) {
              metadataTypes.push("description");
            }
            if (document.getElementById("metadata-transcript").checked) {
              metadataTypes.push("transcript");
            }
            if (document.getElementById("metadata-hash").checked) {
              metadataTypes.push("hash");
            }
            if (document.getElementById("metadata-dimensions").checked) {
              metadataTypes.push("dimensions");
            }
            if (document.getElementById("metadata-autotag").checked) {
              metadataTypes.push("autotag");
            }

            // Validate that at least one metadata type is selected
            if (metadataTypes.length === 0) {
              alert("Please select at least one metadata type to generate");
              return;
            }

            // Add metadata types as comma-separated list
            args.push("--type", metadataTypes.join(","));

            // Add apply scope
            const applyScope =
              document.getElementById("apply-scope-select").value;
            args.push("--apply", applyScope);

            // Add AI model
            const ollamaModel = document
              .getElementById("ollama-model")
              .value.trim();
            if (ollamaModel) {
              args.push("--model", ollamaModel);
            }

            // Add overwrite flag if checked
            if (overwriteCheckbox.checked) {
              args.push("--overwrite");
            }

            input = Array.from(selectedItems).join("\n");
          } else if (selectedTask === "autotag") {
            command = "autotag";
            args = [];
            // Pass comma-separated list to support multi-file in one task
            input = Array.from(selectedItems).join(",");
          }

          // Disable the button
          executeButton.disabled = true;
          executeButton.textContent = "Executing...";

          // Create the job - properly quote the input to treat it as a single argument
          let formattedInput = "";
          if (input) {
            // Escape any quotes in the input and wrap the entire input in quotes
            const escapedInput = input.replace(/"/g, '\\"');
            formattedInput = `"${escapedInput}"`;
          }

          const jobData = {
            input: `${command} ${args.join(" ")} ${formattedInput}`,
          };

          fetch("/create", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(jobData),
          })
            .then((response) => {
              if (response.ok) {
                return response.json();
              }
              throw new Error("Failed to create job");
            })
            .then((result) => {
              // Show a non-blocking notification and link inline in the Job column
              showNotification(`Job created: ${result.id}`, "success");
              attachJobLinksToRows(Array.from(selectedItems), result.id);
              clearSelection();
            })
            .catch((error) => {
              console.error("Error creating job:", error);
              alert("Error creating job. Please try again.");
            })
            .finally(() => {
              executeButton.disabled = false;
              executeButton.textContent = "Execute";
            });
        });

      // Media preview functionality
      let previewTimeout;
      let hideTimeout;
      const previewDelay = 500; // ms
      const hideDelay = 300; // ms

      function isImageFile(path) {
        if (!path || typeof path !== "string") return false;
        const imageExtensions = [
          ".jpg",
          ".jpeg",
          ".png",
          ".gif",
          ".bmp",
          ".webp",
          ".svg",
          ".tiff",
          ".ico",
        ];
        try {
          const lastDotIndex = path.lastIndexOf(".");
          if (lastDotIndex === -1 || lastDotIndex === path.length - 1)
            return false;
          const ext = path.toLowerCase().substring(lastDotIndex);
          return imageExtensions.includes(ext);
        } catch (e) {
          return false;
        }
      }

      function isVideoFile(path) {
        if (!path || typeof path !== "string") return false;
        const videoExtensions = [
          ".mp4",
          ".webm",
          ".ogg",
          ".avi",
          ".mov",
          ".wmv",
          ".flv",
          ".mkv",
          ".m4v",
        ];
        try {
          const lastDotIndex = path.lastIndexOf(".");
          if (lastDotIndex === -1 || lastDotIndex === path.length - 1)
            return false;
          const ext = path.toLowerCase().substring(lastDotIndex);
          return videoExtensions.includes(ext);
        } catch (e) {
          return false;
        }
      }

      function isRemoteUrl(path) {
        return path.startsWith("http://") || path.startsWith("https://");
      }

      function getMediaUrl(path) {
        // Validate path
        if (!path || typeof path !== "string") {
          throw new Error("Invalid path");
        }

        // Trim and validate path length
        path = path.trim();
        if (path.length === 0) {
          throw new Error("Empty path");
        }
        if (path.length > 1000) {
          throw new Error("Path too long");
        }

        if (isRemoteUrl(path)) {
          return path;
        }

        // For local files, properly encode the path
        try {
          return `/media/file?path=${encodeURIComponent(path)}`;
        } catch (e) {
          throw new Error("Failed to encode path");
        }
      }

      function showMediaPreview(event, mediaPath) {
        clearTimeout(hideTimeout);

        // Validate media path
        if (
          !mediaPath ||
          typeof mediaPath !== "string" ||
          mediaPath.trim() === ""
        ) {
          return;
        }

        // Trim and sanitize the path
        mediaPath = mediaPath.trim();

        if (!isImageFile(mediaPath) && !isVideoFile(mediaPath)) {
          return;
        }

        const preview = document.getElementById("media-preview");
        const header = document.getElementById("preview-header");
        const content = document.getElementById("preview-content");
        const footer = document.getElementById("preview-footer");

        previewTimeout = setTimeout(() => {
          // Position the preview near the mouse
          const rect = event.target.getBoundingClientRect();

          let left = event.clientX + 10;
          let top = event.clientY - 10;

          // Adjust if preview would go off screen
          if (left + 400 > window.innerWidth) {
            left = event.clientX - 410;
          }
          if (top + 300 > window.innerHeight) {
            top = event.clientY - 310;
          }

          preview.style.left = Math.max(10, left) + "px";
          preview.style.top = Math.max(10, top) + "px";

          // Show preview
          preview.style.display = "block";
          setTimeout(() => preview.classList.add("show"), 10);

          // Set header with safe file name extraction
          const fileName = extractFileName(mediaPath);
          header.textContent = fileName;

          // Show loading
          content.innerHTML =
            '<div class="media-preview-loading">Loading...</div>';

          let mediaUrl;
          try {
            mediaUrl = getMediaUrl(mediaPath);
          } catch (e) {
            content.innerHTML = `<div class="media-preview-error">Invalid path<br>${escapeHtml(
              e.message
            )}</div>`;
            footer.textContent = "Path error";
            return;
          }

          if (isImageFile(mediaPath)) {
            const img = new Image();
            img.onload = function () {
              content.innerHTML = "";
              content.appendChild(img);
              footer.textContent = `Image • ${img.naturalWidth}×${img.naturalHeight}`;
            };
            img.onerror = function () {
              content.innerHTML =
                '<div class="media-preview-error">Failed to load image<br>Check if file exists and is accessible</div>';
              footer.textContent = "Error loading media";
            };

            // Set a timeout for loading to prevent hanging
            setTimeout(() => {
              if (!img.complete) {
                img.src = ""; // Cancel loading
                content.innerHTML =
                  '<div class="media-preview-error">Loading timeout<br>File may be too large or inaccessible</div>';
                footer.textContent = "Loading timeout";
              }
            }, 10000); // 10 second timeout

            img.src = mediaUrl;
          } else if (isVideoFile(mediaPath)) {
            const video = document.createElement("video");
            video.muted = true;
            video.autoplay = true;
            video.loop = true;
            video.controls = false;
            video.preload = "metadata";

            video.onloadedmetadata = function () {
              content.innerHTML = "";
              content.appendChild(video);
              const duration = Math.round(video.duration);
              footer.textContent = `Video • ${video.videoWidth}×${video.videoHeight} • ${duration}s`;
            };

            video.onerror = function () {
              content.innerHTML =
                '<div class="media-preview-error">Failed to load video<br>Check if file exists and is accessible</div>';
              footer.textContent = "Error loading media";
            };

            // Set a timeout for loading
            setTimeout(() => {
              if (video.readyState === 0) {
                video.src = ""; // Cancel loading
                content.innerHTML =
                  '<div class="media-preview-error">Loading timeout<br>File may be too large or inaccessible</div>';
                footer.textContent = "Loading timeout";
              }
            }, 15000); // 15 second timeout for videos

            video.src = mediaUrl;
          }
        }, previewDelay);
      }

      // Helper function to safely extract filename from path
      function extractFileName(path) {
        try {
          // Handle both forward and backward slashes
          const parts = path.split(/[/\\]/);
          const fileName = parts[parts.length - 1];
          // Limit filename length for display
          return fileName.length > 50
            ? fileName.substring(0, 47) + "..."
            : fileName;
        } catch (e) {
          return "Unknown File";
        }
      }

      function hideMediaPreview() {
        clearTimeout(previewTimeout);

        hideTimeout = setTimeout(() => {
          const preview = document.getElementById("media-preview");
          preview.classList.remove("show");
          setTimeout(() => {
            preview.style.display = "none";
            // Clean up any media elements to stop playback and free memory
            const content = document.getElementById("preview-content");
            const videos = content.querySelectorAll("video");
            videos.forEach((video) => {
              video.pause();
              video.src = "";
              video.load(); // Reset video element
            });
            const images = content.querySelectorAll("img");
            images.forEach((img) => {
              img.src = ""; // Cancel any pending image loads
            });
          }, 300);
        }, hideDelay);
      }

      // Add event listeners to preview element to prevent hiding when hovering over it
      document
        .getElementById("media-preview")
        .addEventListener("mouseenter", () => {
          clearTimeout(hideTimeout);
        });

      document
        .getElementById("media-preview")
        .addEventListener("mouseleave", hideMediaPreview);

      function formatBytes(bytes) {
        if (bytes === 0) return "0 B";
        const k = 1024;
        const sizes = ["B", "KB", "MB", "GB", "TB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
      }

      function loadMoreItems() {
        if (isLoading || !hasMoreItems) return;

        isLoading = true;
        document.getElementById("loading").style.display = "block";

        const queryParams = new URLSearchParams({
          offset: currentOffset,
          limit: 25,
        });

        if (currentSearchQuery) {
          queryParams.set("q", currentSearchQuery);
        }

        fetch(`/media/api?${queryParams}`)
          .then((response) => response.json())
          .then((data) => {
            const mediaList = document.getElementById("media-list");

            data.items.forEach((item) => {
              const row = document.createElement("div");
              row.className = "media-row";

              // Build tags HTML
              let tagsHtml = "-";
              if (item.tags && item.tags.length > 0) {
                tagsHtml = item.tags
                  .map(
                    (tag) =>
                      `<span class="tag-item"><span class="tag-category">${escapeHtml(
                        tag.category
                      )}</span>:${escapeHtml(tag.label)}</span>`
                  )
                  .join("");
              }

              row.innerHTML = `
                <div class="media-cell checkbox" data-label="Select">
                  <input type="checkbox" class="media-checkbox" value="${escapeHtml(
                    item.path
                  )}" onchange="updateSelection()">
                </div>
                <div class="media-cell path" data-label="Path" data-media-path="${escapeHtml(
                  item.path
                )}" onmouseenter="showMediaPreview(event, this.dataset.mediaPath)" onmouseleave="hideMediaPreview()">${escapeHtml(
                item.path
              )}</div>
                <div class="media-cell description" data-label="Description">${escapeHtml(
                  item.description || "-"
                )}</div>
                <div class="media-cell dimensions" data-label="Width">${
                  item.width || "-"
                }</div>
                <div class="media-cell dimensions" data-label="Height">${
                  item.height || "-"
                }</div>
                <div class="media-cell size" data-label="Size">${
                  item.size ? formatBytes(item.size) : "Unknown"
                }</div>
                <div class="media-cell exists" data-label="Exists">${
                  item.exists ? "✅" : "❌"
                }</div>
                <div class="media-cell hash" data-label="Hash">${escapeHtml(
                  item.hash || "-"
                )}</div>
                <div class="media-cell tags" data-label="Tags">${tagsHtml}</div>
              `;
              mediaList.appendChild(row);

              // Keep grid in sync
              appendGridItem(item.path);
            });

            currentOffset += data.items.length;
            hasMoreItems = data.has_more;

            if (!hasMoreItems) {
              document.getElementById("end-of-list").style.display = "block";
            }
          })
          .catch((error) => {
            console.error("Error loading more items:", error);
          })
          .finally(() => {
            isLoading = false;
            document.getElementById("loading").style.display = "none";
          });
      }

      function escapeHtml(text) {
        if (text == null || text === undefined) {
          return "";
        }
        const div = document.createElement("div");
        div.textContent = String(text);
        return div.innerHTML;
      }

      function performSearch(query) {
        const queryParams = new URLSearchParams();
        if (query) {
          queryParams.set("q", query);
        }

        // Redirect to reload the page with the new search
        window.location.href = `/media?${queryParams}`;
      }

      // Search form handling
      document
        .getElementById("search-form")
        .addEventListener("submit", function (e) {
          e.preventDefault();
          const query = document.getElementById("search-input").value.trim();
          performSearch(query);
        });

      // Clear search button
      document
        .getElementById("clear-search")
        .addEventListener("click", function () {
          document.getElementById("search-input").value = "";
          performSearch("");
        });

      // Infinite scroll implementation
      function checkScroll() {
        const scrollTop =
          window.pageYOffset || document.documentElement.scrollTop;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.offsetHeight;

        // Load more when user is within 200px of the bottom
        if (scrollTop + windowHeight >= documentHeight - 200) {
          loadMoreItems();
        }
      }

      // Throttled scroll event listener
      let scrollTimeout;
      window.addEventListener("scroll", function () {
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }
        scrollTimeout = setTimeout(checkScroll, 100);
      });

      // Load initial items if the page is not tall enough to scroll
      document.addEventListener("DOMContentLoaded", function () {
        // View toggle buttons
        const tableBtn = document.getElementById("view-table");
        const gridBtn = document.getElementById("view-grid");
        tableBtn.addEventListener("click", () => setViewMode("table"));
        gridBtn.addEventListener("click", () => setViewMode("grid"));
        initViewMode();

        setTimeout(() => {
          if (
            document.documentElement.offsetHeight <= window.innerHeight &&
            hasMoreItems
          ) {
            loadMoreItems();
          }
        }, 100);
      });

      // EventSource for real-time updates
      document.addEventListener("DOMContentLoaded", function () {
        let eventSource = null;
        const connectEventSource = () => {
          if (!navigator.onLine) {
            console.warn("Offline. EventSource will not connect.");
            return;
          }

          console.log("Connecting to EventSource...");
          eventSource = new EventSource("/stream");

          eventSource.onopen = () => {
            console.log("EventSource connected.");
          };

          eventSource.onerror = (error) => {
            console.error("EventSource error:", error);
            if (eventSource.readyState === EventSource.CLOSED) {
              console.log("Retrying EventSource connection in 3 seconds...");
              setTimeout(connectEventSource, 3000);
            }
          };

          eventSource.addEventListener("update", (event) => {
            const jobUpdate = JSON.parse(event.data);
            const job = jobUpdate.job;

            // Check if this is a job completion that affects media
            if (job.state === 2) {
              // StateCompleted = 2
              handleJobCompletion(job);
            }
          });
        };

        connectEventSource();

        window.addEventListener("beforeunload", (e) => {
          if (eventSource) {
            eventSource.close();
            console.log("EventSource connection closed.");
          }
        });

        window.addEventListener("online", connectEventSource);
        window.addEventListener("offline", () => {
          if (eventSource) {
            eventSource.close();
            console.log("EventSource closed due to offline status.");
          }
        });
      });

      // Grid helpers
      function initViewMode() {
        setViewMode(currentViewMode);
      }

      function setViewMode(mode) {
        currentViewMode = mode === "grid" ? "grid" : "table";
        localStorage.setItem("mediaViewMode", currentViewMode);
        const tableEl = document.getElementById("media-table");
        const gridEl = document.getElementById("media-grid");
        const tableBtn = document.getElementById("view-table");
        const gridBtn = document.getElementById("view-grid");
        if (currentViewMode === "grid") {
          tableEl.style.display = "none";
          gridEl.style.display = "grid";
          tableBtn.classList.remove("active");
          gridBtn.classList.add("active");
          ensureGridInitialized();
        } else {
          tableEl.style.display = "block";
          gridEl.style.display = "none";
          gridBtn.classList.remove("active");
          tableBtn.classList.add("active");
        }
      }

      function ensureGridInitialized() {
        if (gridInitialized) return;
        gridInitialized = true;

        // Build initial grid items from current table rows
        const rows = document.querySelectorAll(
          "#media-list .media-row .media-cell.path"
        );
        rows.forEach((cell) => {
          const path =
            cell.getAttribute("data-media-path") || cell.textContent.trim();
          appendGridItem(path);
        });

        // Setup IntersectionObserver
        gridObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                loadGridMedia(entry.target);
                gridObserver.unobserve(entry.target);
              }
            });
          },
          { root: null, rootMargin: "100px", threshold: 0.01 }
        );

        // Observe all current items
        document.querySelectorAll("#media-grid .grid-item").forEach((el) => {
          gridObserver.observe(el);
        });
      }

      function appendGridItem(path) {
        if (!path) return;
        const grid = document.getElementById("media-grid");
        const item = document.createElement("div");
        item.className = "grid-item";
        item.setAttribute("data-path", path);
        item.setAttribute("data-loaded", "0");
        const badge = document.createElement("div");
        badge.className = "grid-badge";
        badge.textContent = isVideoFile(path) ? "Video" : "Image";
        item.appendChild(badge);
        item.addEventListener("click", () => openLightbox(path));
        grid.appendChild(item);
        if (gridObserver) {
          gridObserver.observe(item);
        }
      }

      function loadGridMedia(itemEl) {
        if (!itemEl || itemEl.getAttribute("data-loaded") === "1") return;
        const path = itemEl.getAttribute("data-path");
        let url;
        try {
          url = getMediaUrl(path);
        } catch (e) {
          return;
        }
        if (isImageFile(path)) {
          const img = new Image();
          img.className = "grid-thumb";
          img.loading = "lazy";
          img.src = url;
          img.alt = "";
          itemEl.appendChild(img);
        } else if (isVideoFile(path)) {
          const video = document.createElement("video");
          video.className = "grid-thumb";
          video.muted = true;
          video.playsInline = true;
          video.autoplay = false;
          video.controls = false;
          video.preload = "metadata";
          video.src = url;
          itemEl.appendChild(video);
        }
        itemEl.setAttribute("data-loaded", "1");
      }

      // Lightbox
      const lightbox = document.getElementById("lightbox");
      const lightboxContent = document.getElementById("lightbox-content");
      const lightboxClose = document.getElementById("lightbox-close");

      function openLightbox(path) {
        while (lightboxContent.firstChild)
          lightboxContent.removeChild(lightboxContent.firstChild);
        let url;
        try {
          url = getMediaUrl(path);
        } catch (e) {
          return;
        }
        if (isImageFile(path)) {
          const img = new Image();
          img.src = url;
          img.alt = "";
          lightboxContent.appendChild(img);
        } else if (isVideoFile(path)) {
          const video = document.createElement("video");
          video.src = url;
          video.controls = true; // show controls in fullscreen
          video.muted = true; // keep muted by default
          video.autoplay = true;
          video.playsInline = true;
          video.preload = "auto";
          lightboxContent.appendChild(video);
        }
        lightbox.classList.add("show");
        lightbox.setAttribute("aria-hidden", "false");
      }

      function closeLightbox() {
        const vids = lightboxContent.querySelectorAll("video");
        vids.forEach((v) => {
          v.pause();
          v.src = "";
          v.load();
        });
        while (lightboxContent.firstChild)
          lightboxContent.removeChild(lightboxContent.firstChild);
        lightbox.classList.remove("show");
        lightbox.setAttribute("aria-hidden", "true");
      }

      lightbox.addEventListener("click", (e) => {
        if (e.target === lightbox) closeLightbox();
      });
      lightboxClose.addEventListener("click", closeLightbox);
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && lightbox.classList.contains("show"))
          closeLightbox();
      });

      function handleJobCompletion(job) {
        const mediaAffectingCommands = [
          "remove",
          "metadata",
          "ingest",
          "cleanup",
          "move",
          "autotag",
        ]; // include autotag

        if (!mediaAffectingCommands.includes(job.command)) {
          return; // Job doesn't affect media
        }

        console.log("Media-affecting job completed:", job);
        // Update any Job column links pointing at this job
        updateJobLinks(job);

        switch (job.command) {
          case "remove":
            handleRemoveJobCompletion(job);
            break;
          case "metadata":
            handleMetadataJobCompletion(job);
            break;
          case "ingest":
            handleIngestJobCompletion(job);
            break;
          case "cleanup":
            handleCleanupJobCompletion(job);
            break;
          case "move":
            handleMoveJobCompletion(job);
            break;
          case "autotag":
            // For autotag, refresh affected rows to show new tags
            handleMetadataJobCompletion(job);
            break;
        }
      }

      // Attach a job link into the Job column for the given rows
      function attachJobLinksToRows(paths, jobId) {
        if (!paths || !jobId) return;
        paths.forEach((path) => {
          const rows = document.querySelectorAll(".media-row");
          Array.from(rows).forEach((row) => {
            const pathCell = row.querySelector(".media-cell.path");
            if (pathCell && pathCell.textContent.trim() === path) {
              const jobCell = row.querySelector(".media-cell.job");
              if (jobCell) {
                jobCell.innerHTML = `<a href="/job/${jobId}" target="_blank" style="color:#61dafb">Job ${jobId}</a>`;
              }
            }
          });
        });
      }

      function updateJobLinks(job) {
        if (!job || !job.id) return;
        const jobLinks = document.querySelectorAll(".media-cell.job a");
        Array.from(jobLinks).forEach((a) => {
          if (a.getAttribute("href") === `/job/${job.id}`) {
            a.textContent = `Job ${job.id} (done)`;
          }
        });
      }

      function handleRemoveJobCompletion(job) {
        // For remove jobs, we need to parse the input to get affected paths
        const input = job.input;
        if (!input) return;

        const paths = input
          .split("\n")
          .map((path) => path.trim())
          .filter((path) => path);

        // Remove rows from the current view
        paths.forEach((path) => {
          const rows = document.querySelectorAll(".media-row");
          rows.forEach((row) => {
            const pathCell = row.querySelector(".media-cell.path");
            if (pathCell && pathCell.textContent.trim() === path) {
              row.remove();
              // Also remove from selected items if it was selected
              selectedItems.delete(path);
            }
          });
        });

        // Update selection UI
        updateSelection();

        showNotification(
          `Removed ${paths.length} media item(s) from database`,
          "success"
        );
      }

      function handleMetadataJobCompletion(job) {
        // For metadata jobs, we need to refresh the affected rows
        const input = job.input;
        if (!input) return;

        // Parse paths from input (newline separated)
        const paths = input
          .split("\n")
          .map((path) => path.trim())
          .filter((path) => path);

        // Refresh affected rows by fetching updated data
        refreshMediaRows(paths);

        showNotification(
          `Updated metadata for ${paths.length} media item(s)`,
          "success"
        );
      }

      function handleIngestJobCompletion(job) {
        // For ingest jobs, new media might have been added
        // We could either reload the entire list or show a notification
        showNotification(
          "Media ingest completed. New items may be available.",
          "info"
        );

        // If we're showing all items (no search), we could reload
        if (!currentSearchQuery) {
          // Optionally ask user if they want to refresh
          if (
            confirm(
              "New media items have been ingested. Would you like to refresh the list?"
            )
          ) {
            window.location.reload();
          }
        }
      }

      function handleCleanupJobCompletion(job) {
        // For cleanup jobs, some items might have been removed
        showNotification(
          "Database cleanup completed. Some items may have been removed.",
          "info"
        );

        // Could optionally reload the entire list
        if (
          confirm(
            "Database cleanup completed. Would you like to refresh the list to see changes?"
          )
        ) {
          window.location.reload();
        }
      }

      function handleMoveJobCompletion(job) {
        // For move jobs, file paths in the database have been updated to new locations
        const input = job.input;
        if (!input) return;

        // Parse paths from input (newline separated for move jobs)
        const originalPaths = input
          .split("\n")
          .map((path) => path.trim())
          .filter((path) => path);

        // Remove the original rows since the paths have changed
        originalPaths.forEach((path) => {
          const rows = document.querySelectorAll(".media-row");
          rows.forEach((row) => {
            const pathCell = row.querySelector(".media-cell.path");
            if (pathCell && pathCell.textContent.trim() === path) {
              row.remove();
              // Also remove from selected items if it was selected
              selectedItems.delete(path);
            }
          });
        });

        // Update selection UI
        updateSelection();

        showNotification(
          `Moved ${originalPaths.length} media item(s) to new location`,
          "success"
        );

        // Suggest refreshing to see the moved items at their new paths
        if (
          confirm(
            "Files have been moved successfully. Would you like to refresh the list to see the updated paths?"
          )
        ) {
          window.location.reload();
        }
      }

      function refreshMediaRows(paths) {
        // For each path, find the row and refresh it with updated data
        paths.forEach((path) => {
          // Find the row for this path
          const rows = document.querySelectorAll(".media-row");
          const targetRow = Array.from(rows).find((row) => {
            const pathCell = row.querySelector(".media-cell.path");
            return pathCell && pathCell.textContent.trim() === path;
          });

          if (targetRow) {
            refreshSingleMediaRow(targetRow, path);
          }
        });
      }

      function refreshSingleMediaRow(rowElement, path) {
        // Fetch updated data for this specific media item
        const encodedPath = encodeURIComponent(path);

        fetch(`/media/api?path=${encodedPath}&single=true`)
          .then((response) => response.json())
          .then((data) => {
            if (data.items && data.items.length > 0) {
              const item = data.items[0];
              updateRowWithNewData(rowElement, item);
            }
          })
          .catch((error) => {
            console.error("Error refreshing media row:", error);
          });
      }

      function updateRowWithNewData(rowElement, item) {
        // Find and update specific cells
        const descriptionCell = rowElement.querySelector(
          ".media-cell.description"
        );
        if (descriptionCell) {
          descriptionCell.textContent = item.description || "-";
        }

        const widthCells = rowElement.querySelectorAll(
          ".media-cell.dimensions"
        );
        if (widthCells.length >= 1) {
          widthCells[0].textContent = item.width || "-";
        }
        if (widthCells.length >= 2) {
          widthCells[1].textContent = item.height || "-";
        }

        const hashCell = rowElement.querySelector(".media-cell.hash");
        if (hashCell) {
          hashCell.textContent = item.hash || "-";
        }

        const tagsCell = rowElement.querySelector(".media-cell.tags");
        if (tagsCell) {
          let tagsHtml = "-";
          if (item.tags && item.tags.length > 0) {
            tagsHtml = item.tags
              .map(
                (tag) =>
                  `<span class="tag-item"><span class="tag-category">${escapeHtml(
                    tag.category
                  )}</span>:${escapeHtml(tag.label)}</span>`
              )
              .join("");
          }
          tagsCell.innerHTML = tagsHtml;
        }

        // Add a subtle animation to indicate the row was updated
        rowElement.style.backgroundColor = "#2a4a3a";
        setTimeout(() => {
          rowElement.style.backgroundColor = "";
        }, 2000);
      }

      function showNotification(message, type = "info") {
        // Create a notification element
        const notification = document.createElement("div");
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 10000;
          padding: 12px 20px;
          border-radius: 6px;
          color: white;
          font-weight: bold;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          max-width: 400px;
          word-wrap: break-word;
          transition: opacity 0.3s ease;
        `;

        switch (type) {
          case "success":
            notification.style.backgroundColor = "#28a745";
            break;
          case "error":
            notification.style.backgroundColor = "#dc3545";
            break;
          case "info":
          default:
            notification.style.backgroundColor = "#17a2b8";
            break;
        }

        notification.textContent = message;
        document.body.appendChild(notification);

        // Auto-remove after 5 seconds
        setTimeout(() => {
          notification.style.opacity = "0";
          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 300);
        }, 5000);
      }

      function htmlToNode(html) {
        const template = document.createElement("template");
        template.innerHTML = html.trim();
        const nNodes = template.content.childNodes.length;
        if (nNodes !== 1) {
          throw new Error(
            `html parameter must represent a single node; got ${nNodes}. ` +
              "Note that leading or trailing spaces around an element in your " +
              'HTML, like " <img/> ", get parsed as text nodes neighbouring ' +
              "the element; call .trim() on your input to avoid this."
          );
        }
        return template.content.firstChild;
      }
    </script>
  </body>
</html>
{{ end }}
