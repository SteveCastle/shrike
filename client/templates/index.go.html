{{ define "home" }}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Shrike Job Manager</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      /* Styles for the terminal-like input */
      #createForm {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      #uri {
        background: transparent;
        border: none;
        outline: none;
        width: 100%;
        color: #0f0;
        font-family: monospace;
        font-size: 1rem;
        /* Ensures the caret (insertion point) is visible and styled: */
        caret-color: #0f0;
      }

      /* Optional: a subtle blinking caret animation can be added with pseudo-elements.
         However, modern browsers show the caret blinking by default. If you want a custom animation:

         @keyframes blink {
           0% { opacity: 1; }
           50% { opacity: 0; }
           100% { opacity: 1; }
         }
         
         #uri:focus {
           animation: blink 1s step-start infinite;
         }
      */
    </style>
  </head>
  <body>
    <h1>Shrike Job Manager</h1>
    <form id="createForm">
      <!-- Removed the submit button. Now pressing Enter on the input triggers submit. -->
      <input
        type="text"
        name="uri"
        id="uri"
        placeholder="Type command and press Enter..."
        autofocus
      />
    </form>
    <!-- A list where we will append incoming messages -->
    <div class="datatable">
      <div class="header">
        <div class="header-column">ID</div>
        <div class="header-column">Command</div>
        <div class="header-column">Arguments</div>
        <div class="header-column">Input</div>
        <div class="header-column">State</div>
        <div class="header-column">CreatedAt</div>
        <div class="header-column">Actions</div>
      </div>
      <div id="jobs" class="table-body">
        {{range .Jobs}} {{template "job" .}} {{end}}
      </div>
    </div>
    <script>
      // Set up the SSE connection
      const eventSource = new EventSource("/stream");

      eventSource.addEventListener("create", (event) => {
        const newJob = JSON.parse(event.data);
        const node = htmlToNode(newJob.html);
        const jobsElement = document.getElementById("jobs");
        jobsElement.insertBefore(node, jobsElement.firstChild);
      });

      eventSource.addEventListener("update", (event) => {
        const modifiedJob = JSON.parse(event.data);
        const node = htmlToNode(modifiedJob.html);
        const jobElement = document.getElementById(modifiedJob.job.id);
        jobElement.replaceWith(node);
      });

      // Handle form submission by sending a fetch request
      document
        .getElementById("createForm")
        .addEventListener("submit", function (e) {
          e.preventDefault();
          const input = document.getElementById("uri").value;

          // Send a POST request to the /create endpoint
          fetch("/create", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ input }),
          })
            .then((response) => response.text())
            .then((result) => {
              console.log("Server responded:", result);
              // Clear the input after submit
              document.getElementById("uri").value = "";
            })
            .catch((err) => console.error("Error:", err));
        });

      // Handle Cancel Button Click
      function cancelJob(e) {
        e.preventDefault();
        const id = e.target.getAttribute("data-id");
        fetch("/cancel", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id }),
        })
          .then((response) => response.text())
          .then((result) => {
            console.log("Server responded:", result);
          })
          .catch((err) => console.error("Error:", err));
      }

      function htmlToNode(html) {
        const template = document.createElement("template");
        template.innerHTML = html.trim();
        const nNodes = template.content.childNodes.length;
        if (nNodes !== 1) {
          throw new Error(
            `html parameter must represent a single node; got ${nNodes}. ` +
              "Note that leading or trailing spaces around an element in your " +
              'HTML, like " <img/> ", get parsed as text nodes neighbouring ' +
              "the element; call .trim() on your input to avoid this."
          );
        }
        return template.content.firstChild;
      }
    </script>
  </body>
</html>
{{ end }}
